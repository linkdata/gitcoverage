# Generate code coverage badge and push it to the 'coverage' branch.
# Reference it in your README.md like this:
#
#  [![coverage](https://github.com/USERNAME/REPO/blob/coverage/BRANCH/badge.svg)](#)
#
# If you submitted a detailed HTML report of the coverage, replace the '#' with:
#
#  https://htmlpreview.github.io/?https://github.com/USERNAME/REPO/blob/coverage/BRANCH/report.html
#
# You need to have given write permissions for the for the workflow:
#
#   permissions:
#     contents: write

name: "gitcoverage"
branding:
  icon: "percent"
  color: "green"
description: "Create/update <branch>/badge.svg (+ optional report.html) on the 'coverage' branch."
author: "johan@linkdata.se"
inputs:
  coverage:
    description: "Coverage percentage (e.g. 83 or 83%)"
    required: true
  report:
    description: "Optional path to an HTML coverage report file to publish as report.html"
    required: false
runs:
  using: "composite"
  steps:
    - name: Sanity / git identity
      shell: bash
      run: |
        set -euo pipefail
        git config --global --add safe.directory "$GITHUB_WORKSPACE"
        git config --local user.email "action@github.com"
        git config --local user.name  "GitHub Action"

    - name: Detect current branch (handles tags; fetches tags; robust)
      id: branch
      shell: bash
      run: |
        set -euo pipefail

        resolve_default_branch() {
          git symbolic-ref --quiet --short refs/remotes/origin/HEAD 2>/dev/null | sed 's@^origin/@@' || true
        }

        # --- Ensure we have enough history + refs ---
        # Make sure 'origin' is set (usually already set by actions/checkout)
        git remote set-url origin "${GITHUB_SERVER_URL:-https://github.com}/${GITHUB_REPOSITORY}.git" || true

        if git rev-parse --is-shallow-repository >/dev/null 2>&1 && [[ "$(git rev-parse --is-shallow-repository)" == "true" ]]; then
          # Fully unshallow if possible so --contains works reliably
          git fetch --prune --tags --unshallow origin || git fetch --prune --tags --depth=1000 origin
        else
          git fetch --prune --tags origin
        fi
        # Fetch all remote heads so we can query them locally
        git fetch origin +refs/heads/*:refs/remotes/origin/* --prune

        # --- Fast paths: PR source branch or branch ref ---
        if [[ -n "${GITHUB_HEAD_REF:-}" ]]; then
          BRANCH="${GITHUB_HEAD_REF}"
        elif [[ "${GITHUB_REF_TYPE:-}" == "branch" && -n "${GITHUB_REF_NAME:-}" ]]; then
          BRANCH="${GITHUB_REF_NAME}"
        else
          BRANCH=""
        fi

        # --- Tag path: map tag -> containing branch ---
        if [[ -z "$BRANCH" ]] && { [[ "${GITHUB_REF_TYPE:-}" == "tag" ]] || [[ "${GITHUB_REF:-}" == refs/tags/* ]]; }; then
          TAG="${GITHUB_REF_NAME:-${GITHUB_REF#refs/tags/}}"
          TAG_REF="tags/$TAG"
          echo "Ref is a tag (${TAG}); resolving containing branch..."

          # 1) Prefer remote branches that contain the tag commit
          mapfile -t RMATCHES < <(git branch -r --format "%(refname:short)" --contains "$TAG_REF" 2>/dev/null || true)
          CANDIDATES=()
          for r in "${RMATCHES[@]}"; do
            [[ "$r" == origin/HEAD ]] && continue
            CANDIDATES+=("${r#origin/}")
          done

          # 2) If none (common in shallow graphs), pick branches whose TIP == tag commit
          if [[ ${#CANDIDATES[@]} -eq 0 ]]; then
            TAG_SHA="$(git rev-list -n1 "$TAG_REF")"
            mapfile -t ALL_R < <(git for-each-ref --format='%(refname:short)' refs/remotes/origin/)
            for rb in "${ALL_R[@]}"; do
              [[ "$rb" == origin/HEAD ]] && continue
              b="${rb#origin/}"
              BR_SHA="$(git rev-parse "$rb" 2>/dev/null || true)"
              [[ -n "$BR_SHA" && "$BR_SHA" == "$TAG_SHA" ]] && CANDIDATES+=("$b")
            done
          fi

          # 3) Choose best candidate: origin/HEAD > main/master > first
          DEF="$(resolve_default_branch)"
          if [[ -n "$DEF" ]]; then
            for b in "${CANDIDATES[@]}"; do [[ "$b" == "$DEF" ]] && BRANCH="$b" && break; done
          fi
          if [[ -z "$BRANCH" ]]; then
            for pref in main master; do
              for b in "${CANDIDATES[@]}"; do [[ "$b" == "$pref" ]] && BRANCH="$b" && break 2; done
            done
          fi
          if [[ -z "$BRANCH" && ${#CANDIDATES[@]} -gt 0 ]]; then
            BRANCH="${CANDIDATES[0]}"
          fi
        fi

        # --- Last resorts: never return a detached HEAD string ---
        if [[ -z "$BRANCH" || "$BRANCH" == "HEAD" || "$BRANCH" =~ ^\(.+\)$ ]]; then
          BRANCH="$(resolve_default_branch)"
        fi
        if [[ -z "$BRANCH" || "$BRANCH" == "HEAD" || "$BRANCH" =~ ^\(.+\)$ ]]; then
          echo "Could not determine branch (still detached at a tag). Consider actions/checkout with 'fetch-depth: 0'." >&2
          exit 1
        fi

        echo "Resolved branch: $BRANCH"
        echo "branch=$BRANCH" >> "$GITHUB_OUTPUT"

    - name: Ensure 'coverage' branch exists (create orphan if needed)
      env:
        BRANCH: ${{ steps.branch.outputs.branch }}
      shell: bash
      run: |
        set -euo pipefail
        # Does 'coverage' branch exist on origin?
        if git ls-remote --exit-code --heads origin coverage >/dev/null 2>&1; then
          echo "'coverage' branch exists."
        else
          echo "Creating orphan 'coverage' branch..."
          git checkout "${BRANCH}"
          git checkout --orphan coverage
          # remove index entries (keep working tree)
          if [[ -n "$(git ls-files)" ]]; then
            git rm --cached $(git ls-files)
          fi
          echo '# Coverage branch' > README.md
          git add README.md
          git commit -m 'Add README.md'
          # Push with auth via checkout action's token/remote config
          git push origin coverage
          git checkout --force "${BRANCH}"
        fi

    - name: Check out coverage branch (worktree)
      shell: bash
      run: |
        set -euo pipefail
        # Use a worktree so we don't disturb current checkout
        rm -rf coverage
        git worktree prune || true
        git worktree add -B coverage coverage origin/coverage
        echo "Using worktree at ./coverage"

    - name: Prepare coverage/<branch> directory
      shell: bash
      env:
        BRANCH: ${{ steps.branch.outputs.branch }}
      run: |
        set -euo pipefail
        mkdir -p "coverage/${BRANCH}"

    - name: Parse coverage input and generate SVG badge
      shell: bash
      env:
        BRANCH: ${{ steps.branch.outputs.branch }}
        INPUT_COVERAGE: ${{ inputs.coverage }}
      run: |
        set -euo pipefail

        # --- 1) Normalize and validate percentage ---
        RAW="$INPUT_COVERAGE"
        PCT="$(echo "$RAW" | sed 's/[[:space:]]//g; s/%$//')"
        if ! [[ "$PCT" =~ ^([0-9]+([.][0-9]+)?)$ ]]; then
          echo "Invalid coverage value: '$RAW' (expected a number like 83 or 83%)." >&2
          exit 1
        fi
        # Clamp and standardize to 0..100 with 2 decimals; display as integer
        PCT=$(awk -v v="$PCT" 'BEGIN{ if (v<0) v=0; if (v>100) v=100; printf("%.2f", v) }')
        VALUE="$(printf "%.0f" "$PCT")%"

        # --- 2) Compute color with 0->33->66->100 anchors (smooth) ---
        read HEX < <(awk -v p="$PCT" '
          function hsl2hex(h,s,l,   c,x,m,r,g,b,R,G,B) {
            c=(1 - ((2*l-1)<0?-(2*l-1):(2*l-1))) * s
            hprime=h/60.0
            x=c*(1 - ((hprime%2)-1<0? -((hprime%2)-1) : ((hprime%2)-1)))
            if      (0<=hprime && hprime<1){r=c; g=x; b=0}
            else if (1<=hprime && hprime<2){r=x; g=c; b=0}
            else if (2<=hprime && hprime<3){r=0; g=c; b=x}
            else if (3<=hprime && hprime<4){r=0; g=x; b=c}
            else if (4<=hprime && hprime<5){r=x; g=0; b=c}
            else if (5<=hprime && hprime<6){r=c; g=0; b=x}
            else {r=0; g=0; b=0}
            m=l - c/2.0
            R=int((r+m)*255+0.5); G=int((g+m)*255+0.5); B=int((b+m)*255+0.5)
            return sprintf("#%02X%02X%02X", R,G,B)
          }
          function lerp(a,b,t){ return a + (b-a)*t }
          BEGIN{
            # Hue anchors (deg): 0=red, 30=orange, 60=yellow, 120=green
            if (p <= 33) {
              h = lerp(0,   30,  p/33.0)
            } else if (p <= 66) {
              h = lerp(30,  60, (p-33.0)/33.0)
            } else if (p < 100) {
              h = lerp(60, 120, (p-66.0)/34.0)
            } else {
              h = 120
            }
            s = 1.0
            l = 0.42    # constant lightness for smoothness/contrast
            print hsl2hex(h,s,l)
          }')
        echo "Computed color $HEX for ${PCT}%"

        # --- 3) Variable width calculation (approx text widths) ---
        LABEL="coverage"

        # crude width table (px) for Verdana/DejaVu Sans at 11px; good enough for badges
        calc_width() {
          local s="$1"
          awk -v s="$s" '
            BEGIN{
              # baseline
              for(i=0;i<=9;i++) w[sprintf("%d",i)]=7
              w["%"]=8; w["."]=3; w["-"]=5; w["_"]=7; w[" "]=4
              split("abcdefghijklmnopqrstuvwxyz",a,""); for(i in a) w[a[i]]=7
              split("ABCDEFGHIJKLMNOPQRSTUVWXYZ",b,""); for(i in b) w[b[i]]=8
              total=0
              for(i=1;i<=length(s);i++){
                ch=substr(s,i,1)
                if (ch in w) total+=w[ch]; else total+=7
              }
              print total
            }'
        }

        # paddings for each side
        PAD_L=6
        PAD_R=6

        LW=$(calc_width "$LABEL")
        RW=$(calc_width "$VALUE")

        LEFT_W=$((LW + PAD_L + PAD_R))
        RIGHT_W=$((RW + PAD_L + PAD_R))
        WIDTH=$((LEFT_W + RIGHT_W))

        LABEL_X=$(( LEFT_W / 2 ))
        LABEL_X_SHADOW=$(( LABEL_X + 1 ))
        VALUE_X=$(( LEFT_W + RIGHT_W / 2 ))
        VALUE_X_SHADOW=$(( VALUE_X + 1 ))

        # --- 4) Emit SVG ---
        SVG="$(cat <<EOF
        <svg xmlns="http://www.w3.org/2000/svg" width="${WIDTH}" height="20" role="img" aria-label="${LABEL}: ${VALUE}">
          <linearGradient id="s" x2="0" y2="100%">
            <stop offset="0" stop-opacity=".1" stop-color="#EEE"/>
            <stop offset="1" stop-opacity=".1"/>
          </linearGradient>
          <mask id="m"><rect width="${WIDTH}" height="20" rx="3" fill="#fff"/></mask>
          <g mask="url(#m)">
            <rect width="${LEFT_W}" height="20" fill="#555"/>
            <rect x="${LEFT_W}" width="${RIGHT_W}" height="20" fill="${HEX}"/>
            <rect width="${WIDTH}" height="20" fill="url(#s)"/>
          </g>
          <g fill="#fff" text-anchor="middle" font-family="Verdana,DejaVu Sans,sans-serif" font-size="11">
            <text x="${LABEL_X_SHADOW}" y="15" fill="#000" opacity="0.25">${LABEL}</text>
            <text x="${LABEL_X}" y="14">${LABEL}</text>
            <text x="${VALUE_X_SHADOW}" y="15" fill="#000" opacity="0.25">${VALUE}</text>
            <text x="${VALUE_X}" y="14">${VALUE}</text>
          </g>
        </svg>
        EOF
        )"

        echo "$SVG" > "coverage/${BRANCH}/badge.svg"

    - name: Copy optional report.html
      if: ${{ inputs.report != '' }}
      env:
        BRANCH: ${{ steps.branch.outputs.branch }}
      shell: bash
      run: |
        set -euo pipefail
        SRC="${{ inputs.report }}"
        if [[ ! -f "$SRC" ]]; then
          echo "Report file not found at: $SRC" >&2
          exit 1
        fi
        cp -f "$SRC" "coverage/${BRANCH}/report.html"

    - name: Commit & push changes to coverage branch
      env:
        BRANCH: ${{ steps.branch.outputs.branch }}
      shell: bash
      run: |
        set -euo pipefail
        pushd coverage >/dev/null
          git config --local user.email "action@github.com"
          git config --local user.name  "GitHub Action"
          test ! -f "${BRANCH}/badge.svg"  || git add "${BRANCH}/badge.svg"
          test ! -f "${BRANCH}/report.html" || git add "${BRANCH}/report.html"
          if [[ -n "$(git status --porcelain)" ]]; then
            git commit -m "update"
            git push origin HEAD:coverage
          else
            echo "No changes to commit."
          fi
        popd >/dev/null

    - name: Summary
      env:
        BRANCH: ${{ steps.branch.outputs.branch }}
      shell: bash
      run: |
        set -euo pipefail
        echo "Published:"
        echo " - ${BRANCH}/badge.svg"
        if [[ -f "coverage/${BRANCH}/report.html" ]]; then
          echo " - ${BRANCH}/report.html"
        fi
